{"expireTime":9007200869033791000,"key":"transformer-remark-markdown-html-f5f7d6bb6969433d42a9cd76985ed340-gatsby-remark-imagesgatsby-remark-external-linksgatsby-remark-prismjs-","val":"<h1>se puede usar DOCSTRING</h1>\n<p><strong><em>doctest (no es necesario instalarlo)</em></strong>\n<strong><em>con DocTest puedo hacer TEST dentro de la funciones de un  archivo .py</em></strong></p>\n<hr>\n<h1>Ejemplos de Testing basicos</h1>\n<p>la suma de 2 mas 2 debe ser igual a 4 (DocTest)  </p>\n<p><code class=\"language-text\">&gt; &gt; &gt; 2 + 2</code><br>\n<code class=\"language-text\">&gt; &gt; &gt; 4</code></p>\n<p>el numero fibonacci 12 debe ser 144 (DocTest)  </p>\n<p><code class=\"language-text\">&gt; &gt; &gt; from funciones import fibonacci</code><br>\n<code class=\"language-text\">&gt; &gt; &gt; fubonacci(12)</code><br>\n<code class=\"language-text\">&gt; &gt; &gt; 144</code>  </p>\n<p>el resultado de la clase recursivo debe ser 120 ya que es el factorial de 5 (DocString)</p>\n<p><code class=\"language-text\">&quot;&quot;&quot;</code><br>\n<code class=\"language-text\">&gt; &gt; &gt; recursivo = Recursivo()</code><br>\n<code class=\"language-text\">&gt; &gt; &gt; recursivo.factorial(5)</code><br>\n<code class=\"language-text\">&gt; &gt; &gt; 120</code><br>\n<code class=\"language-text\">&gt; &gt; &gt;</code><br>\n<code class=\"language-text\">&quot;&quot;&quot;</code>  </p>\n<h1>libreria pytest</h1>\n<p>la libreria pytest + assert (para hacer mas compactos)</p>\n<p><code class=\"language-text\">&gt; &gt; &gt; assert 3==3</code>\npermite crear pruebas en solo 1 linea de codigo<br>\nmostrara error si falla y no mostrara nada si pasa la prueba   </p>\n<h1>LIBRERIA UNITEST framework</h1>\n<p><strong><em>unittest.TestCase permite  usar este framework y sus funcions de testing</em></strong>  </p>\n<h3>Metodos de unittest.Case</h3>\n<ul>\n<li>\n<p>algunos ejemplos rapidos</p>\n<ul>\n<li>assetEqual // metood iguales Compara valores</li>\n<li>assertNotEqual // metodo no iguales Compara valores</li>\n<li>setUp // metodo antes de hacer la prueba(leer variables de entorno , consume api ,    -conectar a BD , escribir sobre un archivo.)</li>\n<li>tearDown // metood despues de la prueba</li>\n<li>assertTrue // regreso true?</li>\n<li>assertFalse // regreso false?</li>\n<li>assertIs // el resultado es el que indicamos? Compara Objetos</li>\n<li>assertIsNot // el resultado NO es el que indicamos? Compara Objetos</li>\n<li>assertRaises// la excepcion obtenida es la excepcion esperada?</li>\n<li>assertGreat // se obtiene valor sobre</li>\n<li>assertLess // se obtiene valor menor que</li>\n<li>asserEqual // se obtiene mismo valor</li>\n<li>\n<p>assertRegex // revisa que el resultado conteniga lo que se esperaba , como un nombre especifico</p>\n<h3>Extras mas conocidos</h3>\n</li>\n<li>metodo FAIL // una forma de hacer testing de forma manual especificando el mensaje error.</li>\n<li>metodo skip // con @unitest.skip('no sabemos como usar esta prueba y la quiero saltar')</li>\n<li>metodo skipIf// con @unitest.skipIf(true , \"se saltara esta prueba ya que lo pasado entrego true\")</li>\n</ul>\n</li>\n</ul>\n<h3>Reportes de cobertura del codigo al hacer testing con unittest?</h3>\n<ul>\n<li>\n<p>coverage report -m archivotesteado.py </p>\n<ul>\n<li>entrega total de lineas testeadas y sus resultados</li>\n</ul>\n</li>\n</ul>\n<h1>Como revisar este reporte por browser?</h1>\n<ul>\n<li>pythonX -m http.server y probablemente lo levante en port 8000</li>\n</ul>"}